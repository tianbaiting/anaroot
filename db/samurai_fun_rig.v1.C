// -*- mode: c++ -*-
// 
// File /home/gibelin/Programs/Geant4/samurai/simtree_rigidity.C generated by TMultiDimFit::MakeRealCode
// on Thu Jul  6 21:24:48 2017
// ROOT version 5.32/00
//
// This file contains the function 
//
//    double  MDF(double *x); 
//
// For evaluating the parameterization obtained
// from TMultiDimFit and the point x
// 
// See TMultiDimFit class documentation for more information 
// 
//
// Static data variables
//
static int    gNVariables    = 6;
static int    gNCoefficients = 60;
static double gDMean         = 6.91402;
// Assignment to mean vector.
static double gXMean[] = {
  -0.0649118, 0.113415, 0.0182191, 0.0192747, 0.286251, 0.292524 };

// Assignment to minimum vector.
static double gXMin[] = {
  -86.0487, -98.4333, -0.0434778, -0.0514167, -1141.92, -177.43 };

// Assignment to maximum vector.
static double gXMax[] = {
  86.5223, 81.4119, 0.0436185, 0.0514507, 902.787, 97.4918 };

// Assignment to coefficients vector.
static double gCoefficient[] = {
  -32.8791,
  8.67604,
  0.092937,
  -290.211,
  -0.290247,
  -34.9542,
  1000.98,
  0.0154683,
  -115.794,
  -0.0239638,
  0.23406,
  -6.74586,
  29.5424,
  -0.0887182,
  0.0740498,
  -0.00509485,
  -0.0445117,
  396.433,
  -100.846,
  20.7342,
  -35.5865,
  0.0446431,
  0.196542,
  -29.5906,
  0.00428709,
  -0.00363279,
  0.00142716,
  -0.00246318,
  -0.00901495,
  -0.0419482,
  0.0428849,
  53.1598,
  -15.522,
  -0.00129601,
  0.0741113,
  0.00228079,
  0.000171955,
  -0.00073036,
  -0.714422,
  0.0140107,
  -0.0954034,
  0.00727289,
  0.00395891,
  -0.018079,
  -0.00340742,
  0.0339417,
  -0.00756767,
  -0.0309005,
  -0.00809372,
  0.00197693,
  -0.00254229,
  0.00991191,
  -0.000477074,
  0.00011445,
  -0.00190271,
  -0.00021049,
  -0.000510377,
  -3.61777e-05,
  -0.000235312,
  0.00174618
 };

// Assignment to error coefficients vector.
static double gCoefficientRMS[] = {
  94.9655,
  118.098,
  2.2416,
  1101.35,
  2.4721,
  146.962,
  3773.39,
  0.161916,
  358.725,
  8.23367,
  14.9389,
  6.4459,
  85.2493,
  0.822536,
  0.613017,
  0.0853042,
  0.0955496,
  1228.46,
  291.934,
  13.7676,
  138.377,
  0.231948,
  1.18704,
  111.555,
  0.205042,
  1.39145,
  0.636958,
  0.236533,
  0.165225,
  4.83583,
  0.422144,
  117.08,
  34.1896,
  0.160775,
  0.343964,
  0.785914,
  1.42651,
  0.683764,
  2.42935,
  0.29351,
  0.820878,
  0.341036,
  1.1575,
  2.20807,
  1.11406,
  0.37452,
  0.701015,
  4.35983,
  1.54853,
  0.24612,
  0.480723,
  4.70507,
  0.757733,
  0.0996321,
  1.00874,
  0.994157,
  0.881793,
  0.0853277,
  1.22109,
  4.04097
 };

// Assignment to powers vector.
// The powers are stored row-wise, that is
//  p_ij = gPower[i * NVariables + j];
static int    gPower[] = {
  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  2,
  2,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  2,  1,
  1,  1,  2,  1,  1,  1,
  1,  1,  1,  1,  1,  3,
  1,  1,  1,  1,  2,  2,
  1,  3,  1,  1,  1,  1,
  2,  1,  2,  1,  1,  1,
  1,  1,  1,  2,  1,  2,
  1,  2,  1,  1,  1,  2,
  1,  1,  1,  1,  3,  1,
  1,  2,  1,  2,  1,  1,
  1,  1,  2,  1,  2,  1,
  2,  1,  1,  1,  2,  1,
  2,  1,  1,  1,  3,  1,
  1,  1,  2,  1,  3,  1,
  2,  1,  2,  1,  1,  2,
  1,  2,  1,  2,  1,  2,
  1,  1,  1,  1,  3,  2,
  1,  2,  1,  1,  1,  3,
  1,  1,  1,  3,  1,  1,
  1,  2,  1,  2,  2,  1,
  1,  2,  1,  1,  1,  1,
  1,  1,  3,  1,  1,  1,
  2,  1,  1,  3,  1,  1,
  1,  2,  1,  3,  1,  1,
  3,  1,  1,  1,  2,  1,
  3,  1,  1,  1,  1,  1,
  1,  2,  2,  2,  1,  1,
  2,  1,  3,  1,  1,  1,
  2,  1,  1,  2,  1,  2,
  2,  1,  1,  2,  1,  1,
  1,  1,  1,  2,  2,  1,
  1,  2,  1,  1,  2,  1,
  1,  1,  2,  2,  1,  1,
  1,  1,  3,  2,  1,  1,
  2,  2,  1,  1,  2,  1,
  2,  1,  2,  1,  2,  1,
  1,  1,  3,  1,  2,  1,
  2,  1,  1,  2,  2,  1,
  1,  1,  1,  3,  2,  1,
  3,  1,  1,  2,  1,  1,
  2,  2,  1,  1,  1,  2,
  1,  3,  2,  1,  1,  1,
  3,  1,  2,  1,  1,  1,
  1,  2,  2,  1,  1,  1,
  2,  2,  1,  2,  1,  1,
  1,  1,  2,  3,  1,  1,
  1,  3,  1,  1,  2,  1,
  1,  3,  1,  2,  1,  1,
  2,  1,  2,  2,  1,  1,
  1,  2,  2,  1,  2,  1,
  1,  1,  1,  2,  3,  1,
  2,  3,  1,  1,  1,  1,
  3,  2,  1,  1,  1,  1,
  1,  1,  2,  2,  2,  1,
  1,  2,  1,  1,  3,  1,
  1,  2,  3,  1,  1,  1,
  2,  2,  2,  1,  1,  1
};

// 
// The function   double MDF(double *x)
// 
double MDF(double *x) {
  double returnValue = gDMean;
  int    i = 0, j = 0, k = 0;
  for (i = 0; i < gNCoefficients ; i++) {
    // Evaluate the ith term in the expansion
    double term = gCoefficient[i];
    for (j = 0; j < gNVariables; j++) {
      // Evaluate the polynomial in the jth variable.
      int power = gPower[gNVariables * i + j]; 
      double p1 = 1, p2 = 0, p3 = 0, r = 0;
      double v =  1 + 2. / (gXMax[j] - gXMin[j]) * (x[j] - gXMax[j]);
      // what is the power to use!
      switch(power) {
      case 1: r = 1; break; 
      case 2: r = v; break; 
      default: 
        p2 = v; 
        for (k = 3; k <= power; k++) { 
          p3 = p2 * v;
          p3 = 2 * v * p2 - p1; 
          p1 = p2; p2 = p3; 
        }
        r = p3;
      }
      // multiply this term by the poly in the jth var
      term *= r; 
    }
    // Add this term to the final result
    returnValue += term;
  }
  return returnValue;
}

// EOF for /home/gibelin/Programs/Geant4/samurai/simtree_rigidity.C
