// -*- mode: c++ -*-
// 
// File O24_rigidity.C generated by TMultiDimFit::MakeRealCode
// on Tue Nov 10 13:52:02 2015
// ROOT version 5.32/00
//
// This file contains the function 
//
//    double  MDF(double *x); 
//
// For evaluating the parameterization obtained
// from TMultiDimFit and the point x
// 
// See TMultiDimFit class documentation for more information 
// 
//
// Static data variables
//
static int    gNVariables    = 6;
static int    gNCoefficients = 76;
static double gDMean         = 7.41004;
// Assignment to mean vector.
static double gXMean[] = {
  0.0187355, -0.00218687, -0.00289588, -0.00952437, 0.106203, -0.40635 };

// Assignment to minimum vector.
static double gXMin[] = {
  -204.857, -135.487, -0.0885213, -0.0770279, -1147.98, -393.282 };

// Assignment to maximum vector.
static double gXMax[] = {
  197.202, 138.356, 0.0912616, 0.0785179, 1126.78, 932.549 };

// Assignment to coefficients vector.
static double gCoefficient[] = {
  3.47626,
  8.90779,
  1.76146,
  -7.91404,
  2.59264,
  -13.5169,
  2.33115,
  3.85541,
  4.02182,
  2.4939,
  -0.384792,
  0.341851,
  -10.2352,
  7.04705,
  25.1534,
  2.4601,
  -7.43812,
  -0.280101,
  0.0417617,
  0.0681293,
  -0.46621,
  -0.0523687,
  -0.143711,
  -0.834292,
  5.62937,
  9.89174,
  62.4521,
  19.2611,
  2.456,
  5.40922,
  -4.0326,
  -0.36484,
  -5.74428,
  8.46792,
  0.0214741,
  -0.0441224,
  -0.0236935,
  -25.9894,
  5.51909,
  0.0426143,
  1.38218,
  2.77755,
  -2.51526,
  6.97483,
  -3.25423,
  0.106766,
  0.0573199,
  -0.0125324,
  0.00965542,
  -7.96678,
  17.1854,
  -0.0322942,
  4.86624,
  -4.29843,
  0.00647897,
  -0.037768,
  0.0808165,
  -0.0183445,
  -0.029811,
  -0.0145287,
  0.0404779,
  -10.5033,
  11.9763,
  1.69444,
  -7.03483,
  -0.0153002,
  -0.00391548,
  4.18401,
  -17.3036,
  -0.00238549,
  -0.00933942,
  0.0108518,
  -0.00388234,
  -0.00509007,
  -0.000799903,
  -0.0025463
 };

// Assignment to error coefficients vector.
static double gCoefficientRMS[] = {
  5.46232,
  13.3662,
  6.38063,
  7.86429,
  4.50801,
  10.9247,
  3.61361,
  10.5399,
  7.67026,
  9.24938,
  3.20577,
  0.0133846,
  10.0397,
  22.4639,
  21.1606,
  2.28254,
  6.49299,
  0.522115,
  0.406233,
  0.132809,
  1.10414,
  0.066359,
  0.0687227,
  7.88535,
  8.8874,
  25.9269,
  52.0564,
  55.2657,
  3.29818,
  4.79125,
  3.48523,
  0.768237,
  5.13299,
  7.27169,
  0.0716899,
  0.23349,
  0.310926,
  24.7146,
  5.58508,
  0.275949,
  4.84938,
  3.57057,
  2.59651,
  8.08718,
  11.0557,
  0.383761,
  0.543317,
  0.124015,
  0.0633316,
  27.1951,
  19.8759,
  0.30017,
  9.84356,
  9.47653,
  0.42036,
  1.13932,
  1.29001,
  0.421977,
  0.444581,
  0.394838,
  1.01579,
  23.2964,
  24.2152,
  12.9944,
  15.1399,
  0.357265,
  0.0783324,
  31.9677,
  37.2461,
  0.33398,
  0.344346,
  0.433255,
  0.332384,
  0.283663,
  0.115755,
  0.314719
 };

// Assignment to powers vector.
// The powers are stored row-wise, that is
//  p_ij = gPower[i * NVariables + j];
static int    gPower[] = {
  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  2,
  2,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  2,  1,
  1,  1,  2,  1,  1,  1,
  1,  1,  1,  1,  2,  2,
  1,  3,  1,  1,  1,  1,
  2,  1,  2,  1,  1,  1,
  1,  1,  2,  1,  1,  2,
  2,  1,  1,  1,  1,  2,
  3,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  3,  1,
  1,  2,  1,  2,  1,  1,
  1,  1,  2,  1,  2,  1,
  2,  1,  1,  1,  2,  1,
  1,  1,  1,  3,  1,  1,
  1,  1,  1,  1,  2,  3,
  2,  1,  1,  3,  1,  1,
  2,  1,  2,  1,  2,  1,
  1,  1,  3,  1,  2,  1,
  2,  2,  1,  2,  1,  1,
  2,  1,  1,  1,  3,  1,
  1,  1,  2,  1,  3,  1,
  3,  1,  1,  1,  1,  2,
  1,  3,  1,  1,  1,  2,
  2,  1,  2,  1,  1,  2,
  2,  1,  1,  1,  2,  2,
  1,  1,  2,  1,  2,  2,
  1,  1,  2,  1,  1,  3,
  1,  2,  1,  1,  1,  1,
  1,  1,  1,  2,  1,  1,
  1,  1,  1,  1,  1,  3,
  1,  1,  1,  2,  1,  2,
  1,  2,  1,  1,  1,  2,
  1,  1,  3,  1,  1,  1,
  1,  1,  1,  3,  2,  1,
  1,  3,  2,  1,  1,  1,
  1,  2,  1,  2,  1,  2,
  1,  1,  1,  3,  1,  2,
  3,  1,  2,  1,  1,  1,
  2,  1,  1,  1,  1,  3,
  1,  2,  1,  1,  1,  3,
  1,  1,  1,  2,  1,  3,
  2,  1,  1,  2,  1,  1,
  2,  2,  1,  1,  1,  1,
  1,  2,  1,  3,  1,  1,
  1,  1,  2,  3,  1,  1,
  3,  1,  1,  1,  2,  1,
  1,  2,  1,  1,  3,  1,
  2,  2,  1,  1,  1,  2,
  2,  1,  1,  2,  1,  2,
  2,  3,  1,  1,  1,  1,
  1,  1,  1,  2,  2,  1,
  1,  1,  2,  2,  1,  1,
  1,  1,  3,  2,  1,  1,
  1,  2,  2,  2,  1,  1,
  2,  1,  2,  2,  1,  1,
  2,  1,  1,  2,  2,  1,
  1,  2,  1,  2,  2,  1,
  3,  1,  1,  2,  1,  1,
  2,  2,  2,  1,  1,  1,
  1,  1,  2,  2,  1,  2,
  1,  1,  1,  2,  2,  2,
  1,  2,  2,  1,  1,  1,
  1,  2,  1,  1,  2,  1,
  1,  3,  1,  2,  1,  1,
  1,  1,  1,  2,  3,  1,
  1,  2,  2,  1,  1,  2,
  1,  2,  1,  1,  2,  2,
  2,  2,  1,  1,  2,  1,
  1,  2,  2,  1,  2,  1,
  1,  1,  2,  2,  2,  1,
  1,  2,  3,  1,  1,  1,
  2,  1,  3,  1,  1,  1,
  1,  3,  1,  1,  2,  1,
  3,  2,  1,  1,  1,  1
};

// 
// The function   double MDF(double *x)
// 
double MDF(double *x) {
  double returnValue = gDMean;
  int    i = 0, j = 0, k = 0;
  for (i = 0; i < gNCoefficients ; i++) {
    // Evaluate the ith term in the expansion
    double term = gCoefficient[i];
    for (j = 0; j < gNVariables; j++) {
      // Evaluate the polynomial in the jth variable.
      int power = gPower[gNVariables * i + j]; 
      double p1 = 1, p2 = 0, p3 = 0, r = 0;
      double v =  1 + 2. / (gXMax[j] - gXMin[j]) * (x[j] - gXMax[j]);
      // what is the power to use!
      switch(power) {
      case 1: r = 1; break; 
      case 2: r = v; break; 
      default: 
        p2 = v; 
        for (k = 3; k <= power; k++) { 
          p3 = p2 * v;
          p3 = 2 * v * p2 - p1; 
          p1 = p2; p2 = p3; 
        }
        r = p3;
      }
      // multiply this term by the poly in the jth var
      term *= r; 
    }
    // Add this term to the final result
    returnValue += term;
  }
  return returnValue;
}

// EOF for O24_rigidity.C
